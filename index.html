<!doctype html>
<html>
<head>
    <title>Snake Man</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background: #333;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 2em auto;
            box-shadow: 0 0 10px #aaa;
        }
    </style>
</head>
<body></body>
<script>
  class Snake {
    constructor(x, y) {
      this.pieces = [[x, y]];
    }
  }

  class Pill {
    constructor(x, y, w, h, alive) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;

      this.alive = alive;
      this.color = '#001bd0';
      this.originalColor = '#001bd0';
      this.steps = 0;
    }
  }

  const WORLD = {
    cols: 90,
    rows: 40,
    pW: 20,
    pH: 20,
    paused: false,
  };

  const canvas = document.createElement('canvas');
  canvas.width = WORLD.pW * WORLD.cols;
  canvas.height = WORLD.pH * WORLD.rows;
  const ctx = canvas.getContext('2d');

  document.body.appendChild(canvas);

  const snake = new Snake(50, 30);
  const energy = new Pill(12, 12, WORLD.pW, WORLD.pH, true);

  const keyboard = {
    ArrowLeft: false,
    ArrowUp: false,
    ArrowRight: false,
    ArrowDown: false,
  };

  function render() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (energy.alive) {
      ctx.fillStyle = energy.color;
      ctx.fillRect((energy.x | 0) * WORLD.pW, (energy.y | 0) * WORLD.pH, energy.w, energy.h);
      energy.steps += 1;
      if (energy.steps === 0) {
        energy.color = energy.originalColor;
      }
    }

    snake.pieces.forEach(([x, y], i) => {
      if (i === 0) {
        ctx.fillStyle = '#006c00';
      } else {
        ctx.fillStyle = '#00ff00';
      }
      ctx.fillRect(x * WORLD.pW, y * WORLD.pH, WORLD.pW, WORLD.pH);
    });
  }

  let last = 0;
  let delta = 0;
  let DELAY = 16 * 2;

  function step(t) {
    requestAnimationFrame(step);
    if (WORLD.paused) {
      return;
    }

    delta = t - last;
    if (delta < DELAY) {
      return;
    }
    last = t;

    const head = [snake.pieces[0][0], snake.pieces[0][1]];
    const tail = snake.pieces.pop();

    if (keyboard.ArrowRight) {
      head[0] += 1;
    } else if (keyboard.ArrowLeft) {
      head[0] -= 1;
    } else if (keyboard.ArrowUp) {
      head[1] -= 1;
    } else if (keyboard.ArrowDown) {
      head[1] += 1;
    }

    if (head[0] < 0) {
      head[0] = WORLD.cols;
    } else if (head[0] > WORLD.cols) {
      head[0] = 0;
    } else if (head[1] > WORLD.rows) {
      head[1] = 0;
    } else if (head[1] < 0) {
      head[1] = WORLD.rows;
    }

    snake.pieces.unshift(head);

    if (snake.pieces[0][0] === energy.x && snake.pieces[0][1] === energy.y) {
      energy.color = '#cc0000';
      energy.steps = -25;
      energy.alive = false;
      energy.x = Math.random() * WORLD.cols | 0;
      energy.y = Math.random() * WORLD.rows | 0;
      energy.alive = true;

      snake.pieces.push(tail);
    }

    render();
  }

  document.addEventListener('keydown', (event) => {
    if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(event.code) >= 0) {
      if (
        (keyboard.ArrowDown && event.code === 'ArrowUp') ||
        (keyboard.ArrowUp && event.code === 'ArrowDown') ||
        (keyboard.ArrowRight && event.code === 'ArrowLeft') ||
        (keyboard.ArrowLeft && event.code === 'ArrowRight')) {
        return;
      }
      Object.keys(keyboard).forEach((k) => {
        keyboard[k] = false;
      });
    } else {
      WORLD.paused = true;
    }
    keyboard[event.code] = true;
  });

  document.addEventListener('keyup', (event) => {
    if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(event.code) < 0) {
      WORLD.paused = false;
    }
  });

  requestAnimationFrame(step);
</script>
</html>