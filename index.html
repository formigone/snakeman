<!doctype html>
<html>
<head>
    <title>Snake Man</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background: #333;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 2em auto;
            box-shadow: 0 0 10px #aaa;
        }
    </style>
</head>
<body></body>
<script>
  class Player {
    constructor(x, y, w, h, speed) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = speed;
      this.moving = {
        ArrowLeft: false,
        ArrowUp: false,
        ArrowRight: false,
        ArrowDown: false,
      };
      this.tail = [];
      this.previous = null;
    }
  }

  class Pill {
    constructor(x, y, w, h, alive) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;

      this.alive = alive;
      this.color = '#001bd0';
    }
  }

  const WORLD = {
    cols: 80,
    rows: 40,
    pW: 20,
    pH: 20,
    paused: false,
  };

  const canvas = document.createElement('canvas');
  canvas.width = WORLD.pW * WORLD.cols;
  canvas.height = WORLD.pH * WORLD.rows;
  const ctx = canvas.getContext('2d');

  document.body.appendChild(canvas);

  const hero = new Player(5, 5, WORLD.pW, WORLD.pH, 0.15);
  const energy = new Pill(12, 12, WORLD.pW, WORLD.pH, true);

  const keyboard = {
    ArrowLeft: false,
    ArrowUp: false,
    ArrowRight: false,
    ArrowDown: false,
  };

  function render() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (energy.alive) {
      ctx.fillStyle = energy.color;
      ctx.fillRect((energy.x | 0) * WORLD.pW, (energy.y | 0) * WORLD.pH, energy.w, energy.h);
    }

    ctx.fillStyle = '#006c00';
    ctx.fillRect((hero.x | 0) * WORLD.pW, (hero.y | 0) * WORLD.pH, hero.w, hero.h);
    ctx.fillStyle = '#00a000';
    hero.tail.forEach(({ x, y }) => {
      ctx.fillRect((x | 0) * WORLD.pW, (y | 0) * WORLD.pH, hero.w, hero.h);
      // WORLD.paused = true;
    });
  }

  function tick() {
    requestAnimationFrame(tick);
    if (WORLD.paused) {
      return;
    }

    hero.previous = hero;

    if (hero.moving.ArrowRight) {
      hero.x += hero.speed;
    } else if (hero.moving.ArrowLeft) {
      hero.x -= hero.speed;
    } else if (hero.moving.ArrowUp) {
      hero.y -= hero.speed;
    } else if (hero.moving.ArrowDown) {
      hero.y += hero.speed;
    }

    if (hero.y < 0) {
      hero.y = WORLD.rows - 1;
    } else if (hero.y > WORLD.rows) {
      hero.y = 0;
    } else if (hero.x > WORLD.cols) {
      hero.x = 0;
    } else if (hero.x < 0) {
      hero.x = WORLD.cols;
    }

    if ((hero.x | 0) === (energy.x | 0) && (hero.y | 0) === (energy.y | 0)) {
      energy.color = '#cc0000';
      energy.alive = false;
      energy.x = Math.random() * WORLD.cols | 0;
      energy.y = Math.random() * WORLD.rows | 0;
      energy.alive = true;
      hero.tail.push({ x: hero.x, y: hero.y });
    } else {
      energy.color = '#001bd0';
    }

    // TODO: make tail work
    let prev = hero.previous;
    hero.tail.map(({ x, y }, i) => {
      hero.tail[i].x = prev.x;
      hero.tail[i].y = prev.y;
      // prev = hero.tail[i];
    });
    render();
  }

  document.addEventListener('keydown', (event) => {
    keyboard[event.code] = true;
    if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(event.code) >= 0) {
      Object.keys(hero.moving).forEach((dir) => {
        hero.moving[dir] = false;
      });
      hero.moving[event.code] = true;
    }
  });

  document.addEventListener('keyup', (event) => {
    keyboard[event.code] = false;
  });

  tick();
</script>
</html>